% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/generate_random_curve.R
\name{generate_curve_function}
\alias{generate_curve_function}
\title{Create a function from a set of basis functions and corresponding coefficients}
\usage{
generate_curve_function(basis_functions, coefs, id = NULL)
}
\arguments{
\item{basis_functions}{A list of functions of x that return a vector the same length as x}

\item{coefs}{A list of coefficients, the same length as basis_functions.
Each element of this list is either a vector of length-1 or the length of id.}

\item{id}{NULL, or a unique vector identifying participant numbers.}
}
\value{
if id is NULL: a function of x which returns a data.table with columns "x" and "value".
if id is non-null, a function of both x and id which returns a data.table containing a row for every
combination of x and id,  with columns "x", "id",and "value".
}
\description{
A function which returns a function which itself will return the linear combination of the provided
basis functions and coefficients. Coefficients may be vectors,
allowing for id-specific linear combinations of those basis functions.
}
\details{
Each set of coefficients may be a vector. The ordering of each coefficients
must correspond to each other. ie, if \code{coefs=list(c(1,2), c(3,4))} then 1 and 3 are taken
to be the coefficients for the first and second basis functions respectively for the first id and
2 and 4 are taken to be the coefficients for the first and second basis functions respectively for the second id.
If any element of coefs has length greater than 1, then id must be specified because the return
function will have an id argument (which specifies which set of coefficients to use).
}
\examples{
set.seed(20)
f0 <- function(x){rep(1L,length(x))}
f1 <- function(x){x}
f2 <- generate_random_spline(c(1,100),20, stats::rnorm(n,sd=40),degree=10)
f3 <- generate_random_spline(c(1,100),20, stats::rnorm(n,sd=40),degree=10)

#fixed coefficients
g <- generate_curve_function(list(f0,f1,f2,f3),coefs=list(30,5,1,1))
dt <- g(1:100)
plot(1:100,dt$value, type="l")

#random coefficients
ids <- 1:10
g1 <- generate_curve_function(list(f0,f1,f2,f3),
                             coefs=list(stats::rnorm(length(ids), mean=30),
                                        stats::rnorm(length(ids),mean=5),
                                        stats::rnorm(length(ids)),
                                        stats::rnorm(length(ids))
                             ),
                             id=1:length(ids))
dt1 <- g1(1:100,ids)
plot(1,1,xlim=c(1,100),ylim=range(dt1$value),type="n")
sapply(ids,function(i){lines(dt1[id==i,x],dt1[id==i,value],col=i)})


x <- 1:(365*20)
x_range <- range(x)
shape <- 7.5
avg_daily_hazard=0.000003
curve(dgamma(x,shape=shape,scale=avg_daily_hazard/shape),from=0, to=0.0001)

z <- generate_curve_function(
  basis_functions=list(
    function(x){x-mean(x_range)},
    generate_random_spline(x_range,n_points=20,
                           stats::rgamma(n,shape=shape,scale=avg_daily_hazard/shape),
                           degree=10)
  ),
  coefs=list(-5e-10,1)
)
plot(x,z(x)$value,type="l")




ppts <- 1:10

par(mfrow=c(3,2))
for(j in 1:6){
  z2 <- generate_curve_function(
    basis_functions=list(
      function(x){rep(1L,length(x))},
      function(x){x-mean(x_range)},
      generate_random_spline(x_range,n_points=365, stats::rnorm(n,sd=20),degree=30),
      generate_random_spline(x_range,n_points=365, stats::rnorm(n,sd=20),degree=30)
    ),
    coefs=list(
      stats::rnorm(length(ppts),mean=18),
      stats::rnorm(length(ppts),-0.0009,sd=0.0001),
      stats::rnorm(length(ppts),sd=.4),
      stats::rnorm(length(ppts),sd=.4)
    ),
    id=ppts
  )

exposures <- z2(ppts[2:6],x=x)
exposures_ppts <- unique(exposures$id)

plot(1,1,type="n",xlim=x_range,ylim=range(exposures$value))
for(i in 1:length(exposures_ppts))
  exposures[J(exposures_ppts[i]), lines(x=x,y=value,col=i,ylim=c(0,30)),on="id"]
}
par(mfrow=c(1,1))





}
