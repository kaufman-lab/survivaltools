% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/bin_time.R
\name{bin_time}
\alias{bin_time}
\title{Convert Dates/integers to the end of a specified interval}
\usage{
bin_time(x, y, snapto = "end", nonmatcherror = TRUE)
}
\arguments{
\item{x}{A vector of Date, IDates, or integers}

\item{y}{A two-column data.frame or data.table where the start column is the start Date, IDate, or integer
of each period and the second column is the ending value (also Date, IDate, or integer) of each period.
The intervals must be non-overlapping and have no gaps.}

\item{snapto}{a length-1 character vector equalling "start", "end", "mid", or "count". This designates
whether the resulting vector of dates will be the start date, the end date, the midpoint (rounded down)
of each period, or an integer ordered bin count.}

\item{nonmatcherror}{When TRUE, an error will occur if there are values of x not in intervals of y
(ie outside the span of y). When FALSE, elements of the return vector corresponding to
values of x not in intervals of y are returned as NA.}
}
\value{
A vector of the same class as columns of y corresponding to elements of x
}
\description{
\code{bin_time} codes values in x, according to which of the specified intervals they falls into,
to the end (or start or midpoint) of that interval
}
\details{
Similar to cut but only for integers.
Unlike cut it returns the same class as the input (whereas cut returns factor representing the interval).
Easier to use than cut when dealing with a long sequence of intervals.
Note that if objects of class Date have decimal portions these will be silently ignored.
}
\examples{
 bin_time(x=c(1L,6L,2L,14L),y=data.frame(seq(1L,21L,by=5L),seq(5L,25L,by=5L)))
}
